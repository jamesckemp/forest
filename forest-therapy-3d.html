<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forest Therapy - Golden Hour</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div id="loader">Loading Forest...</div>
    <div id="info" style="display: none;">
        Use WASD to move, Mouse to look around<br>
        Press SHIFT to walk slower
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/FXAAShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2; // Increased for dramatic sun effect
        document.body.appendChild(renderer.domElement);

        // Hide loader and show info when ready
        setTimeout(() => {
            document.getElementById('loader').style.display = 'none';
            document.getElementById('info').style.display = 'block';
        }, 1000);

        // Fog for atmosphere and performance
        scene.fog = new THREE.Fog(0xFFD4A3, 5, 100); // Closer fog for misty atmosphere
        scene.background = new THREE.Color(0xFFD4A3);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xFFE4B5, 0.3); // Reduced for dramatic lighting
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xFFC649, 2.0); // Bright golden sun
        sunLight.position.set(800, 200, 600); // Lower in sky for golden hour
        sunLight.target.position.set(0, 0, 0); // Point towards scene center
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 4096; // Higher resolution shadows
        sunLight.shadow.mapSize.height = 4096;
        sunLight.shadow.camera.near = 0.1;
        sunLight.shadow.camera.far = 3000;
        sunLight.shadow.camera.left = -200;
        sunLight.shadow.camera.right = 200;
        sunLight.shadow.camera.top = 200;
        sunLight.shadow.camera.bottom = -200;
        sunLight.shadow.bias = -0.0001;
        scene.add(sunLight);
        scene.add(sunLight.target);

        // Volumetric light rays helper
        const rayLight = new THREE.DirectionalLight(0xFFB85F, 0.3);
        rayLight.position.copy(sunLight.position);
        scene.add(rayLight);

        // Create feathered sun texture
        function createSunTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = canvas.width / 2;
            
            // Create warm, soft radial gradient
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
            gradient.addColorStop(0, 'rgba(255, 180, 120, 0.9)'); // Warm peachy center
            gradient.addColorStop(0.2, 'rgba(255, 150, 80, 0.8)'); // Warm orange
            gradient.addColorStop(0.5, 'rgba(255, 120, 60, 0.6)'); // Deep orange
            gradient.addColorStop(0.7, 'rgba(255, 100, 40, 0.4)'); // Reddish orange
            gradient.addColorStop(0.9, 'rgba(255, 80, 20, 0.2)'); // Deep warm fade
            gradient.addColorStop(1.0, 'rgba(255, 60, 0, 0)'); // Transparent edge
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            return new THREE.CanvasTexture(canvas);
        }

        // Create soft, feathered sun using sprite
        const sunTexture = createSunTexture();
        const sunMaterial = new THREE.SpriteMaterial({
            map: sunTexture,
            color: 0xFF6B35, // Warmer, less bright orange
            fog: false,
            toneMapped: false,
                transparent: true,
            blending: THREE.AdditiveBlending
        });
        
        const sun = new THREE.Sprite(sunMaterial);
        sun.scale.set(80, 80, 1); // Large soft sun
        sun.position.copy(sunLight.position);
        sun.layers.enable(1); // Add to bloom layer
        scene.add(sun);

        // Remove manual glow - will be handled by bloom effect



        // Add additional fog layer for depth
        const fogColor = new THREE.Color(0xFFE4B5);
        renderer.setClearColor(fogColor, 0.8);

        // Ground - much larger to extend infinitely
        const groundGeometry = new THREE.PlaneGeometry(10000, 10000, 100, 100);
        const groundMaterial = new THREE.MeshLambertMaterial({ 
            color: 0x3B5323,
            map: generateGroundTexture()
        });
        
        // Add terrain variation
        const vertices = groundGeometry.attributes.position.array;
        for (let i = 0; i < vertices.length; i += 3) {
            vertices[i + 2] = Math.random() * 0.5 - 0.25;
        }
        groundGeometry.computeVertexNormals();
        
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Generate ground texture
        function generateGroundTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Base color
            ctx.fillStyle = '#3B5323';
            ctx.fillRect(0, 0, 512, 512);
            
            // Add variation
            for (let i = 0; i < 1000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const radius = Math.random() * 20 + 5;
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, `rgba(59, 83, 35, ${Math.random() * 0.3})`);
                gradient.addColorStop(1, 'rgba(59, 83, 35, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(10, 10);
            return texture;
        }

        // Tree creation with LOD
        function createTree(x, z, height) {
            const tree = new THREE.Group();
            
            // Trunk - positioned to sit on ground
            const trunkGeometry = new THREE.CylinderGeometry(height * 0.05, height * 0.08, height * 0.6, 8);
            const trunkMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x4A3C28,
                map: generateBarkTexture()
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = height * 0.3 - 0.2; // Lower to ground level
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            tree.add(trunk);
            
            // Varied, darker foliage layers
            const baseFoliageColors = [
                [0x1A3008, 0x2D5016, 0x0F2004], // Very dark greens
                [0x253A0A, 0x3A5F0B, 0x162508], // Dark forest greens
                [0x2F4A0C, 0x4C7C0F, 0x1E3009]  // Darker medium greens
            ];
            
            // Add color variation based on tree position for natural diversity
            const colorVariation = Math.sin(x * 0.1) * Math.cos(z * 0.1);
            
            for (let i = 0; i < 3; i++) {
                const foliageGeometry = new THREE.SphereGeometry(
                    height * (0.3 - i * 0.05), 
                    8 - i * 2, 
                    6 - i
                );
                
                // Select base color and add variation
                const baseColorArray = baseFoliageColors[i];
                let selectedColor;
                
                if (colorVariation > 0.3) {
                    selectedColor = baseColorArray[0]; // Darkest
                } else if (colorVariation > -0.3) {
                    selectedColor = baseColorArray[1]; // Medium dark
                } else {
                    selectedColor = baseColorArray[2]; // Slightly lighter dark
                }
                
                // Add random tint variation
                const r = (selectedColor >> 16) & 0xFF;
                const g = (selectedColor >> 8) & 0xFF;
                const b = selectedColor & 0xFF;
                
                // Apply slight random variation (±10%)
                const variation = 0.1;
                const newR = Math.max(0, Math.min(255, r + (Math.random() - 0.5) * r * variation));
                const newG = Math.max(0, Math.min(255, g + (Math.random() - 0.5) * g * variation));
                const newB = Math.max(0, Math.min(255, b + (Math.random() - 0.5) * b * variation));
                
                const finalColor = (Math.floor(newR) << 16) | (Math.floor(newG) << 8) | Math.floor(newB);
                
                const foliageMaterial = new THREE.MeshLambertMaterial({ 
                    color: finalColor
                });
                const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                foliage.position.y = height * (0.7 + i * 0.1) - 0.2; // Match trunk lowering
                foliage.scale.y = 0.8;
                foliage.castShadow = true;
                foliage.receiveShadow = true;
                tree.add(foliage);
            }
            
            tree.position.set(x, 0, z);
            return tree;
        }

        // Generate bark texture
        function generateBarkTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#4A3C28';
            ctx.fillRect(0, 0, 128, 256);
            
            // Add bark lines
            ctx.strokeStyle = '#3A2C18';
            ctx.lineWidth = 2;
            for (let i = 0; i < 20; i++) {
                ctx.beginPath();
                ctx.moveTo(Math.random() * 128, 0);
                ctx.lineTo(Math.random() * 128, 256);
                ctx.stroke();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        // Place trees procedurally
        const trees = new Map(); // Use Map to track trees by grid position
        const treeGrid = new Map(); // Track which grid cells have trees
        const GRID_SIZE = 10; // Size of each grid cell
        const VIEW_DISTANCE = 150; // Increased from 100 for earlier generation
        const TREE_DENSITY = 0.45; // Chance of tree in each grid cell (50% more trees)

        // Function to get grid key from position
        function getGridKey(x, z) {
            const gridX = Math.floor(x / GRID_SIZE);
            const gridZ = Math.floor(z / GRID_SIZE);
            return `${gridX},${gridZ}`;
        }

        // Function to generate trees in a grid cell
        function generateTreesInCell(gridX, gridZ, isInitialLoad = false) {
            const key = `${gridX},${gridZ}`;
            if (treeGrid.has(key)) return; // Already generated
            
            // Use deterministic random based on grid position
            const seed = gridX * 1000 + gridZ;
            const random = () => {
                const x = Math.sin(seed) * 10000;
                return x - Math.floor(x);
            };
            
            // Randomly decide if this cell should have a tree
            if (random() < TREE_DENSITY) {
                const x = gridX * GRID_SIZE + (random() - 0.5) * GRID_SIZE;
                const z = gridZ * GRID_SIZE + (random() - 0.5) * GRID_SIZE;
                const height = random() * 18 + 12; // More height variation (12-30)
                
                const tree = createTree(x, z, height);
                
                if (isInitialLoad) {
                    // Initial trees appear immediately
                    scene.add(tree);
                    trees.set(key, { mesh: tree, opacity: 1, targetOpacity: 1 });
                } else {
                    // New trees fade in
                tree.traverse((child) => {
                    if (child.material) {
                        child.material.transparent = true;
                        child.material.opacity = 0;
                    }
                });
                scene.add(tree);
                trees.set(key, { mesh: tree, opacity: 0, targetOpacity: 1 });
                }
                
                treeGrid.set(key, { x, z, radius: 1 });
            }
        }

        // Function to update visible trees based on player position
        function updateTrees(playerX, playerZ) {
            const playerGridX = Math.floor(playerX / GRID_SIZE);
            const playerGridZ = Math.floor(playerZ / GRID_SIZE);
            const gridRange = Math.ceil(VIEW_DISTANCE / GRID_SIZE);
            
            // Generate trees in view range
            for (let dx = -gridRange; dx <= gridRange; dx++) {
                for (let dz = -gridRange; dz <= gridRange; dz++) {
                    const gridX = playerGridX + dx;
                    const gridZ = playerGridZ + dz;
                    const distance = Math.sqrt(dx * dx + dz * dz) * GRID_SIZE;
                    
                    if (distance <= VIEW_DISTANCE) {
                        generateTreesInCell(gridX, gridZ);
                    }
                }
            }
            
            // Remove trees that are too far away
            for (const [key, treeData] of trees.entries()) {
                const [gridX, gridZ] = key.split(',').map(Number);
                const dx = gridX - playerGridX;
                const dz = gridZ - playerGridZ;
                const distance = Math.sqrt(dx * dx + dz * dz) * GRID_SIZE;
                
                if (distance > VIEW_DISTANCE * 1.5) { // Remove with some buffer
                    scene.remove(treeData.mesh);
                    trees.delete(key);
                    treeGrid.delete(key);
                }
            }
        }

        // Initialize trees around starting position - no fade-in for initial load
        function initializeTrees(playerX, playerZ) {
            const playerGridX = Math.floor(playerX / GRID_SIZE);
            const playerGridZ = Math.floor(playerZ / GRID_SIZE);
            const gridRange = Math.ceil(VIEW_DISTANCE / GRID_SIZE);
            
            // Generate initial trees without fade-in
            for (let dx = -gridRange; dx <= gridRange; dx++) {
                for (let dz = -gridRange; dz <= gridRange; dz++) {
                    const gridX = playerGridX + dx;
                    const gridZ = playerGridZ + dz;
                    const distance = Math.sqrt(dx * dx + dz * dz) * GRID_SIZE;
                    
                    if (distance <= VIEW_DISTANCE) {
                        generateTreesInCell(gridX, gridZ, true); // true = initial load
                    }
                }
            }
        }
        
        initializeTrees(0, 10);

        // Selective bloom effect setup
        let materials = {};
        const darkMaterial = new THREE.MeshBasicMaterial({ color: 'black' });

        // Set up effect composers
        const renderPass = new THREE.RenderPass(scene, camera);
        const antialiasPass = new THREE.ShaderPass(THREE.FXAAShader);
        const bloomPass = new THREE.UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            1.5, // strength
            0.4, // radius  
            0.85 // threshold
        );

        // Bloom composer - renders only bloom objects
        const bloomComposer = new THREE.EffectComposer(renderer);
        bloomComposer.addPass(renderPass);
        bloomComposer.addPass(bloomPass);
        bloomComposer.addPass(antialiasPass);
        bloomComposer.renderToScreen = false;

        // Merge shader to combine bloom and main scene
        const mergeShader = {
            uniforms: {
                u_baseTexture: { value: null },
                u_bloomTexture: { value: bloomComposer.readBuffer.texture },
                u_alpha: { value: 0.3 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D u_baseTexture;
                uniform sampler2D u_bloomTexture;
                uniform float u_alpha;
                varying vec2 vUv;
                void main() {
                    gl_FragColor = texture2D(u_baseTexture, vUv) + u_alpha * texture2D(u_bloomTexture, vUv);
                }
            `
        };

        const mergePass = new THREE.ShaderPass(
            new THREE.ShaderMaterial(mergeShader), 
            'u_baseTexture'
        );

        // Main composer - renders full scene and merges bloom
        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderPass);
        composer.addPass(antialiasPass);
        composer.addPass(mergePass);

        // Functions to handle bloom isolation
        function darkenNonBloom(obj) {
            if (obj.isMesh && obj.layers && typeof obj.layers.isEnabled === 'function') {
                if (obj.layers.isEnabled(1) === false) {
                    materials[obj.uuid] = obj.material;
                    obj.material = darkMaterial;
                }
            }
        }

        function restoreMaterial(obj) {
            if (obj.isMesh && materials[obj.uuid]) {
                obj.material = materials[obj.uuid];
                delete materials[obj.uuid];
            }
        }

        // Rock formations
        function createRock(x, z, scale) {
            const rockGeometry = new THREE.DodecahedronGeometry(scale, 0);
            const rockMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x666666
            });
            const rock = new THREE.Mesh(rockGeometry, rockMaterial);
            rock.position.set(x, scale * 0.3, z);
            rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            rock.castShadow = true;
            rock.receiveShadow = true;
            return rock;
        }

        const rocks = new Map();
        const rockGrid = new Map();
        const ROCK_DENSITY = 0.05;

        // Fallen logs system
        const logs = new Map();
        const logGrid = new Map();
        const LOG_DENSITY = 0.03; // Less frequent than rocks

        function generateRocksInCell(gridX, gridZ) {
            const key = `${gridX},${gridZ}`;
            if (rockGrid.has(key)) return;
            
            // Don't place rocks where trees already exist
            if (treeGrid.has(key)) return;
            
            const seed = gridX * 2000 + gridZ * 3;
            const random = () => {
                const x = Math.sin(seed) * 10000;
                return x - Math.floor(x);
            };
            
            if (random() < ROCK_DENSITY) {
                const x = gridX * GRID_SIZE + (random() - 0.5) * GRID_SIZE;
                const z = gridZ * GRID_SIZE + (random() - 0.5) * GRID_SIZE;
                const scale = random() * 2 + 1;
                
                // Double-check for nearby trees to avoid close overlaps
                let tooCloseToTree = false;
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        const checkKey = `${gridX + dx},${gridZ + dz}`;
                        if (treeGrid.has(checkKey)) {
                            const treeData = treeGrid.get(checkKey);
                            const distance = Math.sqrt(
                                Math.pow(x - treeData.x, 2) + 
                                Math.pow(z - treeData.z, 2)
                            );
                            if (distance < 3) { // Minimum 3-unit separation
                                tooCloseToTree = true;
                                break;
                            }
                        }
                    }
                    if (tooCloseToTree) break;
                }
                
                if (!tooCloseToTree) {
                const rock = createRock(x, z, scale);
                scene.add(rock);
                rocks.set(key, rock);
                rockGrid.set(key, { position: new THREE.Vector3(x, 0, z), radius: scale });
                }
            }
        }

        function updateRocks(playerX, playerZ) {
            const playerGridX = Math.floor(playerX / GRID_SIZE);
            const playerGridZ = Math.floor(playerZ / GRID_SIZE);
            const gridRange = Math.ceil(VIEW_DISTANCE / GRID_SIZE);
            
            for (let dx = -gridRange; dx <= gridRange; dx++) {
                for (let dz = -gridRange; dz <= gridRange; dz++) {
                    const gridX = playerGridX + dx;
                    const gridZ = playerGridZ + dz;
                    const distance = Math.sqrt(dx * dx + dz * dz) * GRID_SIZE;
                    
                    if (distance <= VIEW_DISTANCE) {
                        generateRocksInCell(gridX, gridZ);
                    }
                }
            }
            
            for (const [key, rock] of rocks.entries()) {
                const [gridX, gridZ] = key.split(',').map(Number);
                const dx = gridX - playerGridX;
                const dz = gridZ - playerGridZ;
                const distance = Math.sqrt(dx * dx + dz * dz) * GRID_SIZE;
                
                if (distance > VIEW_DISTANCE * 1.5) {
                    scene.remove(rock);
                    rocks.delete(key);
                    rockGrid.delete(key);
                }
            }
        }

        updateRocks(0, 10);

        // Fallen logs
        function createLog(x, z) {
            const logGeometry = new THREE.CylinderGeometry(0.5, 0.7, 8, 8);
            const logMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x3A2C18,
                map: generateBarkTexture()
            });
            const log = new THREE.Mesh(logGeometry, logMaterial);
            log.position.set(x, 0.5, z);
            log.rotation.z = Math.PI / 2;
            log.rotation.y = Math.random() * Math.PI;
            log.castShadow = true;
            log.receiveShadow = true;
            return log;
        }

        function generateLogsInCell(gridX, gridZ) {
            const key = `${gridX},${gridZ}`;
            if (logGrid.has(key)) return;
            
            // Don't place logs where trees or rocks already exist
            if (treeGrid.has(key) || rockGrid.has(key)) return;
            
            const seed = gridX * 3000 + gridZ * 7; // Different seed from trees/rocks
            const random = () => {
                const x = Math.sin(seed) * 10000;
                return x - Math.floor(x);
            };
            
            if (random() < LOG_DENSITY) {
                const x = gridX * GRID_SIZE + (random() - 0.5) * GRID_SIZE;
                const z = gridZ * GRID_SIZE + (random() - 0.5) * GRID_SIZE;
                
                // Check for nearby trees and rocks to avoid overlaps
                let tooCloseToOther = false;
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        const checkKey = `${gridX + dx},${gridZ + dz}`;
                        // Check trees
                        if (treeGrid.has(checkKey)) {
                            const treeData = treeGrid.get(checkKey);
                            const distance = Math.sqrt(
                                Math.pow(x - treeData.x, 2) + 
                                Math.pow(z - treeData.z, 2)
                            );
                            if (distance < 4) { // 4-unit separation from trees
                                tooCloseToOther = true;
                                break;
                            }
                        }
                        // Check rocks
                        if (rockGrid.has(checkKey)) {
                            const rockData = rockGrid.get(checkKey);
                            const distance = Math.sqrt(
                                Math.pow(x - rockData.position.x, 2) + 
                                Math.pow(z - rockData.position.z, 2)
                            );
                            if (distance < 3) { // 3-unit separation from rocks
                                tooCloseToOther = true;
                                break;
                            }
                        }
                    }
                    if (tooCloseToOther) break;
                }
                
                if (!tooCloseToOther) {
            const log = createLog(x, z);
            scene.add(log);
                    logs.set(key, log);
                    logGrid.set(key, { position: new THREE.Vector3(x, 0, z), radius: 4 }); // Log length
                }
            }
        }

        function updateLogs(playerX, playerZ) {
            const playerGridX = Math.floor(playerX / GRID_SIZE);
            const playerGridZ = Math.floor(playerZ / GRID_SIZE);
            const gridRange = Math.ceil(VIEW_DISTANCE / GRID_SIZE);
            
            for (let dx = -gridRange; dx <= gridRange; dx++) {
                for (let dz = -gridRange; dz <= gridRange; dz++) {
                    const gridX = playerGridX + dx;
                    const gridZ = playerGridZ + dz;
                    const distance = Math.sqrt(dx * dx + dz * dz) * GRID_SIZE;
                    
                    if (distance <= VIEW_DISTANCE) {
                        generateLogsInCell(gridX, gridZ);
                    }
                }
            }
            
            for (const [key, log] of logs.entries()) {
                const [gridX, gridZ] = key.split(',').map(Number);
                const dx = gridX - playerGridX;
                const dz = gridZ - playerGridZ;
                const distance = Math.sqrt(dx * dx + dz * dz) * GRID_SIZE;
                
                if (distance > VIEW_DISTANCE * 1.5) {
                    scene.remove(log);
                    logs.delete(key);
                    logGrid.delete(key);
                }
            }
        }

        updateLogs(0, 10);

        // Swaying grass system
        const grassBlades = [];
        const grassCount = 800;
        
        function createGrassBlade(x, z, isClump = false) {
            const height = Math.random() * 0.4 + 0.2; // 0.2-0.6 height
            const width = 0.02;
            const segments = 4; // Number of segments for curvature
            
            // Create custom curved geometry
            const grassGeometry = new THREE.BufferGeometry();
            const vertices = [];
            const indices = [];
            const uvs = [];
            
            // Create curved blade with multiple segments
            const curveAmount = (Math.random() - 0.5) * 0.3; // Random curve direction and amount
            
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const y = t * height;
                
                // Apply quadratic curve: x = curveAmount * t^2
                const curveOffset = curveAmount * t * t;
                
                // Left edge of blade
                vertices.push(-width/2, y, curveOffset);
                uvs.push(0, t);
                
                // Right edge of blade
                vertices.push(width/2, y, curveOffset);
                uvs.push(1, t);
                
                // Create triangles (except for last segment)
                if (i < segments) {
                    const base = i * 2;
                    // First triangle
                    indices.push(base, base + 1, base + 2);
                    // Second triangle
                    indices.push(base + 1, base + 3, base + 2);
                }
            }
            
            grassGeometry.setIndex(indices);
            grassGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            grassGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            grassGeometry.computeVertexNormals();
            
            const grassMaterial = new THREE.MeshLambertMaterial({
                color: new THREE.Color().setHSL(0.27 + Math.random() * 0.06, 0.6, 0.08 + Math.random() * 0.06), // Much darker green
                side: THREE.DoubleSide,
                transparent: false,
                emissive: new THREE.Color().setHSL(0.27, 0.3, 0.02) // Subtle self-illumination to prevent pure black
            });
            
            const grassBlade = new THREE.Mesh(grassGeometry, grassMaterial);
            grassBlade.position.set(x, 0, z); // Position at ground level
            grassBlade.rotation.y = Math.random() * Math.PI; // Random rotation
            
            // Store animation data
            grassBlade.userData = {
                originalRotation: grassBlade.rotation.clone(),
                swayOffset: Math.random() * Math.PI * 2,
                swayAmount: 0.05 + Math.random() * 0.05, // Smaller sway for smaller grass
                originalPosition: grassBlade.position.clone(),
                isClump: isClump
            };
            
            return grassBlade;
        }
        
        function createGrassClump(x, z) {
            const clump = new THREE.Group();
            const clumpSize = 3 + Math.random() * 4; // 3-7 blades per clump
            
            for (let i = 0; i < clumpSize; i++) {
                const offsetX = (Math.random() - 0.5) * 0.3; // Small offset within clump
                const offsetZ = (Math.random() - 0.5) * 0.3;
                const blade = createGrassBlade(x + offsetX, z + offsetZ, true);
                
                // Remove from global position since it's in a group
                blade.position.x = offsetX;
                blade.position.z = offsetZ;
                
                clump.add(blade);
            }
            
            clump.position.set(x, 0, z);
            clump.userData = {
                originalPosition: clump.position.clone(),
                swayOffset: Math.random() * Math.PI * 2,
                swayAmount: 0.03 + Math.random() * 0.03
            };
            
            return clump;
        }
        
        // Generate grass around starting position
        function generateGrass(centerX, centerZ, radius = 50) {
            for (let i = 0; i < grassCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * radius;
                const x = centerX + Math.cos(angle) * distance;
                const z = centerZ + Math.sin(angle) * distance;
                
                // Don't place grass too close to trees, rocks, or logs
                let tooClose = false;
                const checkRadius = 2;
                
                // Check against existing objects (simplified check)
                for (const [key, treeData] of treeGrid.entries()) {
                    const dist = Math.sqrt(Math.pow(x - treeData.x, 2) + Math.pow(z - treeData.z, 2));
                    if (dist < checkRadius + 1) {
                        tooClose = true;
                        break;
                    }
                }
                
                if (!tooClose) {
                    // 40% chance for clumps, 60% for individual blades
                    if (Math.random() < 0.4) {
                        const grassClump = createGrassClump(x, z);
                        grassBlades.push(grassClump);
                        scene.add(grassClump);
                    } else {
                        const grassBlade = createGrassBlade(x, z);
                        grassBlades.push(grassBlade);
                        scene.add(grassBlade);
                    }
                }
            }
        }
        
        // Generate initial grass
        generateGrass(0, 10);

        // Create dust/bug particle texture
        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 12;
            
            // Create circular particle
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(1.0, 'rgba(255, 255, 255, 0.0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            return new THREE.CanvasTexture(canvas);
        }

        // Visible dust particles floating in air
        const dustParticles = [];
        const dustCount = 450; // 50% more particles
        
        for (let i = 0; i < dustCount; i++) {
            const particleTexture = createParticleTexture();
            const particleMaterial = new THREE.SpriteMaterial({
                map: particleTexture,
                color: new THREE.Color().setHSL(0.1, 0.3, 0.9), // Light yellowish
            transparent: true,
            opacity: 0.8,
                fog: false,
                blending: THREE.NormalBlending // Regular blending for visibility
            });
            
            const particle = new THREE.Sprite(particleMaterial);
            particle.scale.set(0.125, 0.125, 1); // 50% smaller again
            
            // Position around player - lower to ground
            particle.position.x = (Math.random() - 0.5) * 100;
            particle.position.y = Math.random() * 8 + 1; // Lower height range
            particle.position.z = (Math.random() - 0.5) * 100;
            
            // Random velocity for floating motion
            particle.userData = {
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.02,
                    (Math.random() - 0.5) * 0.01,
                    (Math.random() - 0.5) * 0.02
                ),
                originalY: particle.position.y,
                bobOffset: Math.random() * Math.PI * 2
            };
            
            dustParticles.push(particle);
            scene.add(particle);
        }

        // Enhanced ground mist particles for atmospheric effect
        const mistCount = 800; // More mist particles
        const mistGeometry = new THREE.BufferGeometry();
        const mistPositions = new Float32Array(mistCount * 3);
        
        for (let i = 0; i < mistCount; i++) {
            mistPositions[i * 3] = (Math.random() - 0.5) * 280; // Much wider
            mistPositions[i * 3 + 1] = Math.random() * 6; // Taller mist
            mistPositions[i * 3 + 2] = (Math.random() - 0.5) * 280;
        }
        
        mistGeometry.setAttribute('position', new THREE.BufferAttribute(mistPositions, 3));
        
        const mistMaterial = new THREE.PointsMaterial({
            color: 0xFFE4B5,
            size: 0.15, // Larger mist particles
            transparent: true,
            opacity: 0.25, // More visible
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            sizeAttenuation: false
        });
        
        const mistSystem = new THREE.Points(mistGeometry, mistMaterial);
        scene.add(mistSystem);
        
        // Add additional floating particles layer
        const extraParticleCount = 400;
        const extraGeometry = new THREE.BufferGeometry();
        const extraPositions = new Float32Array(extraParticleCount * 3);
        const extraVelocities = [];
        
        for (let i = 0; i < extraParticleCount; i++) {
            extraPositions[i * 3] = (Math.random() - 0.5) * 120;
            extraPositions[i * 3 + 1] = Math.random() * 30 + 5; // Mid-height particles
            extraPositions[i * 3 + 2] = (Math.random() - 0.5) * 120;
            extraVelocities.push({
                x: (Math.random() - 0.5) * 0.025,
                y: (Math.random() - 0.5) * 0.01,
                z: (Math.random() - 0.5) * 0.025
            });
        }
        
        extraGeometry.setAttribute('position', new THREE.BufferAttribute(extraPositions, 3));
        
        const extraMaterial = new THREE.PointsMaterial({
            color: 0xFFD4A3,
            size: 0.03,
            transparent: true,
            opacity: 0.7,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            sizeAttenuation: false
        });
        
        const extraParticleSystem = new THREE.Points(extraGeometry, extraMaterial);
        scene.add(extraParticleSystem);

        // Player controls
        const cameraGroup = new THREE.Group();
        cameraGroup.add(camera);
        cameraGroup.position.set(0, 1.7, 10);
        scene.add(cameraGroup);

        // Add spotlight pointing down from camera to illuminate ground
        const playerSpotlight = new THREE.SpotLight(0xFFE4B5, 1.0, 30, Math.PI/4, 0.3); // Dimmed by 50%
        playerSpotlight.position.set(0, 2, 0); // Above player
        playerSpotlight.target.position.set(0, -2, 0); // Point down
        cameraGroup.add(playerSpotlight);
        cameraGroup.add(playerSpotlight.target);

        // Add hemisphere light for general ambient around player
        const playerAmbient = new THREE.HemisphereLight(0xFFE4B5, 0x3B5323, 0.4); // Dimmed by 50%
        cameraGroup.add(playerAmbient);
        
        const movement = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            shift: false
        };

        const playerVelocity = new THREE.Vector3();
        const playerDirection = new THREE.Vector3();
        
        // Mouse controls
        let lat = 0;
        let lon = 0;
        
        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === renderer.domElement) {
                lon += e.movementX * 0.2;
                lat -= e.movementY * 0.2;
                lat = Math.max(-85, Math.min(85, lat));
            }
        });

        renderer.domElement.addEventListener('click', () => {
            renderer.domElement.requestPointerLock();
        });

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            switch(e.key.toLowerCase()) {
                case 'w': movement.forward = true; break;
                case 's': movement.backward = true; break;
                case 'a': movement.left = true; break;
                case 'd': movement.right = true; break;
                case 'shift': movement.shift = true; break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch(e.key.toLowerCase()) {
                case 'w': movement.forward = false; break;
                case 's': movement.backward = false; break;
                case 'a': movement.left = false; break;
                case 'd': movement.right = false; break;
                case 'shift': movement.shift = false; break;
            }
        });

        // Collision detection
        function checkCollision(position) {
            const playerGridX = Math.floor(position.x / GRID_SIZE);
            const playerGridZ = Math.floor(position.z / GRID_SIZE);
            
            // Check nearby grid cells for collisions
            for (let dx = -1; dx <= 1; dx++) {
                for (let dz = -1; dz <= 1; dz++) {
                    const key = `${playerGridX + dx},${playerGridZ + dz}`;
                    
                    // Check tree collisions
                    if (treeGrid.has(key)) {
                        const treePos = treeGrid.get(key);
                        const distance = Math.sqrt(
                            Math.pow(position.x - treePos.x, 2) + 
                            Math.pow(position.z - treePos.z, 2)
                        );
                        if (distance < treePos.radius + 1) {
                            return true;
                        }
                    }
                    
                    // Check rock collisions
                    if (rockGrid.has(key)) {
                        const rock = rockGrid.get(key);
                        const distance = position.distanceTo(rock.position);
                        if (distance < rock.radius + 1) {
                            return true;
                        }
                    }
                }
            }
            
            return false;
        }

        // Audio system for forest ambience
        let audioInitialized = false;
        let forestAudio = null;
        let ambientAudio = null;
        
        // Function to slowly fade out ambient music
        function fadeOutAmbient() {
            if (!ambientAudio || ambientAudio.paused) return;
            
            const fadeStep = 0.005; // How much to reduce volume each step
            const fadeInterval = 100; // Milliseconds between fade steps
            
            const fade = setInterval(() => {
                if (ambientAudio.volume > fadeStep) {
                    ambientAudio.volume -= fadeStep;
                } else {
                    ambientAudio.volume = 0;
                    ambientAudio.pause();
                    clearInterval(fade);
                    console.log('🎵 Ambient music faded out completely');
                }
            }, fadeInterval);
        }
        
        function initAudio() {
            if (!audioInitialized) {
                try {
                    // Initialize forest audio
                    if (!forestAudio) {
                        forestAudio = new Audio('forest.wav');
                        forestAudio.loop = true;
                        forestAudio.volume = 0.6; // Slightly lower to balance with ambient
                        
                        forestAudio.addEventListener('loadstart', () => console.log('Forest audio loading started'));
                        forestAudio.addEventListener('canplay', () => console.log('Forest audio can play'));
                        forestAudio.addEventListener('playing', () => console.log('Forest audio is now playing'));
                        forestAudio.addEventListener('error', (e) => console.log('Forest audio error:', e));
                    }
                    
                    // Initialize ambient audio
                    if (!ambientAudio) {
                        ambientAudio = new Audio('ambient.wav');
                        ambientAudio.loop = false; // Play only once
                        ambientAudio.volume = 0.375; // Ambient at 75% of previous volume
                        
                        ambientAudio.addEventListener('loadstart', () => console.log('Ambient audio loading started'));
                        ambientAudio.addEventListener('canplay', () => console.log('Ambient audio can play'));
                        ambientAudio.addEventListener('playing', () => console.log('Ambient audio is now playing'));
                        ambientAudio.addEventListener('error', (e) => console.log('Ambient audio error:', e));
                        
                        // Start fade out after 30 seconds
                        setTimeout(() => {
                            if (ambientAudio && !ambientAudio.paused) {
                                fadeOutAmbient();
                            }
                        }, 30000); // 30 seconds
                    }
                    
                    // Start both audio tracks
                    Promise.all([
                        forestAudio.play(),
                        ambientAudio.play()
                    ]).then(() => {
                        console.log('✅ Both forest and ambient audio successfully started!');
                audioInitialized = true;
                        removeAudioListeners(); // Remove listeners immediately
                    }).catch(e => {
                        console.log('❌ Audio play failed:', e.message);
                        // Try individual tracks if Promise.all fails
                        forestAudio.play().catch(e => console.log('Forest audio failed:', e.message));
                        ambientAudio.play().catch(e => console.log('Ambient audio failed:', e.message));
                    });
                    
                } catch (error) {
                    console.log('❌ Could not load audio files:', error);
                }
            }
        }
        
        // Try to start audio immediately
        initAudio();
        
        // More comprehensive user interaction listeners
        function tryStartAudio() {
            if (audioInitialized || (forestAudio && !forestAudio.paused && ambientAudio && !ambientAudio.paused)) {
                console.log('🎵 Audio already playing - ignoring interaction');
                removeAudioListeners();
                return;
            }
            console.log('🔊 User interaction detected - attempting to start audio...');
            initAudio();
        }
        
        document.addEventListener('click', tryStartAudio);
        document.addEventListener('keydown', tryStartAudio);
        document.addEventListener('touchstart', tryStartAudio);
        
        // Remove listeners once audio is successfully playing
        function removeAudioListeners() {
            if (audioInitialized && forestAudio && !forestAudio.paused) {
                document.removeEventListener('click', tryStartAudio);
                document.removeEventListener('keydown', tryStartAudio);
                document.removeEventListener('touchstart', tryStartAudio);
                console.log('🎵 Audio listeners removed - ambience is playing');
            }
        }
        
        // Check if audio started every few seconds
        setInterval(() => {
            if (forestAudio && !forestAudio.paused && ambientAudio && !ambientAudio.paused && !audioInitialized) {
                audioInitialized = true;
                removeAudioListeners();
            }
        }, 2000);

        // Animation variables
        let time = 0;
        let bobAmount = 0;

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            time += 0.016;
            
            // Update camera rotation from mouse
            camera.rotation.order = 'YXZ';
            camera.rotation.y = THREE.MathUtils.degToRad(-lon);
            camera.rotation.x = THREE.MathUtils.degToRad(lat);
            
            // Update player movement
            const speed = movement.shift ? 4 : 8; // Doubled from 2/4
            const delta = 0.016;
            
            playerDirection.set(0, 0, 0);
            
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(camera.quaternion);
            forward.y = 0;
            forward.normalize();
            
            const right = new THREE.Vector3(1, 0, 0);
            right.applyQuaternion(camera.quaternion);
            right.y = 0;
            right.normalize();
            
            if (movement.forward) playerDirection.add(forward);
            if (movement.backward) playerDirection.sub(forward);
            if (movement.left) playerDirection.sub(right);
            if (movement.right) playerDirection.add(right);
            
            playerDirection.normalize();
            
            // Apply movement with collision detection
            if (playerDirection.length() > 0) {
                const newPosition = cameraGroup.position.clone();
                newPosition.x += playerDirection.x * speed * delta;
                newPosition.z += playerDirection.z * speed * delta;
                
                if (!checkCollision(newPosition)) {
                    cameraGroup.position.x = newPosition.x;
                    cameraGroup.position.z = newPosition.z;
                    
                    // Update forest generation based on new position
                    updateTrees(newPosition.x, newPosition.z);
                    updateRocks(newPosition.x, newPosition.z);
                    updateLogs(newPosition.x, newPosition.z);
                    
                    // Head bobbing
                    bobAmount += delta * 5;
                    cameraGroup.position.y = 1.7 + Math.sin(bobAmount) * 0.05;
                    
                    // Initialize audio on first movement
                    initAudio();
                }
            }
            
            // Animate dust particles
            const playerX = cameraGroup.position.x;
            const playerZ = cameraGroup.position.z;
            
            dustParticles.forEach((particle, i) => {
                // Apply velocity
                particle.position.add(particle.userData.velocity);
                
                // Add gentle bobbing motion
                particle.position.y = particle.userData.originalY + Math.sin(time * 0.8 + particle.userData.bobOffset) * 0.3;
                
                // Wrap around player
                const wrapDistance = 40;
                if (particle.position.x > playerX + wrapDistance) {
                    particle.position.x = playerX - wrapDistance;
                }
                if (particle.position.x < playerX - wrapDistance) {
                    particle.position.x = playerX + wrapDistance;
                }
                if (particle.position.z > playerZ + wrapDistance) {
                    particle.position.z = playerZ - wrapDistance;
                }
                if (particle.position.z < playerZ - wrapDistance) {
                    particle.position.z = playerZ + wrapDistance;
                }
                
                // Keep particles in lower height range
                if (particle.position.y > 10) {
                    particle.position.y = 1;
                    particle.userData.originalY = 1;
                }
                if (particle.position.y < 0.5) {
                    particle.position.y = 8;
                    particle.userData.originalY = 8;
                }
                
                // Vary opacity slightly for more natural look
                particle.material.opacity = 0.6 + Math.sin(time * 2 + i * 0.5) * 0.2;
            });
            
            // Animate mist with player-relative wrapping
            const mistPositions = mistSystem.geometry.attributes.position.array;
            for (let i = 0; i < mistCount; i++) {
                // Gentle floating motion
                mistPositions[i * 3 + 1] += Math.sin(time * 0.3 + i * 0.05) * 0.003;
                
                // Wrap around player
                const mistWrapDistance = 100;
                if (mistPositions[i * 3] > playerX + mistWrapDistance) mistPositions[i * 3] = playerX - mistWrapDistance;
                if (mistPositions[i * 3] < playerX - mistWrapDistance) mistPositions[i * 3] = playerX + mistWrapDistance;
                if (mistPositions[i * 3 + 1] > 8) mistPositions[i * 3 + 1] = 0;
                if (mistPositions[i * 3 + 1] < 0) mistPositions[i * 3 + 1] = 8;
                if (mistPositions[i * 3 + 2] > playerZ + mistWrapDistance) mistPositions[i * 3 + 2] = playerZ - mistWrapDistance;
                if (mistPositions[i * 3 + 2] < playerZ - mistWrapDistance) mistPositions[i * 3 + 2] = playerZ + mistWrapDistance;
            }
            mistSystem.geometry.attributes.position.needsUpdate = true;
            
            // Animate extra particles
            const extraPositions = extraParticleSystem.geometry.attributes.position.array;
            for (let i = 0; i < extraParticleCount; i++) {
                extraPositions[i * 3] += extraVelocities[i].x;
                extraPositions[i * 3 + 1] += extraVelocities[i].y + Math.sin(time * 0.3 + i) * 0.002;
                extraPositions[i * 3 + 2] += extraVelocities[i].z;
                
                // Wrap particles around
                if (extraPositions[i * 3] > 60) extraPositions[i * 3] = -60;
                if (extraPositions[i * 3] < -60) extraPositions[i * 3] = 60;
                if (extraPositions[i * 3 + 1] > 35) extraPositions[i * 3 + 1] = 5;
                if (extraPositions[i * 3 + 1] < 5) extraPositions[i * 3 + 1] = 35;
                if (extraPositions[i * 3 + 2] > 60) extraPositions[i * 3 + 2] = -60;
                if (extraPositions[i * 3 + 2] < -60) extraPositions[i * 3 + 2] = 60;
            }
            extraParticleSystem.geometry.attributes.position.needsUpdate = true;
            
            // Animate foliage (wind effect) and fade-in
            for (const [key, treeData] of trees.entries()) {
                const tree = treeData.mesh;
                const index = parseInt(key.split(',')[0]) + parseInt(key.split(',')[1]);
                
                // Fade in effect
                if (treeData.opacity < treeData.targetOpacity) {
                    treeData.opacity += 0.02;
                    tree.traverse((child) => {
                        if (child.material) {
                            child.material.opacity = treeData.opacity;
                        }
                    });
                }
                
                // Wind animation
                tree.children.forEach((child, childIndex) => {
                    if (childIndex > 0) { // Skip trunk
                        child.rotation.x = Math.sin(time * 0.5 + index) * 0.02;
                        child.rotation.z = Math.cos(time * 0.3 + index) * 0.02;
                    }
                });
            }
            
            // Animate swaying grass
            grassBlades.forEach((grass, i) => {
                const swayTime = time * 0.8 + grass.userData.swayOffset;
                
                if (grass.isGroup) {
                    // Handle grass clumps - only rotate, keep base fixed
                    grass.rotation.x = Math.sin(swayTime) * grass.userData.swayAmount * 0.3;
                    grass.rotation.z = Math.cos(swayTime * 0.7) * grass.userData.swayAmount * 0.5;
                    // Remove position changes - base should stay rooted
                } else {
                    // Handle individual grass blades - only rotate to keep base planted
                    grass.rotation.z = grass.userData.originalRotation.z + 
                        Math.sin(swayTime) * grass.userData.swayAmount;
                    
                    grass.rotation.x = grass.userData.originalRotation.x + 
                        Math.sin(swayTime * 0.7) * grass.userData.swayAmount * 0.5;
                    
                    // Remove position changes - grass should be rooted at base
                }
                
                // Update grass position relative to player (cull distant grass)
                const grassPlayerDistance = Math.sqrt(
                    Math.pow(grass.position.x - playerX, 2) + 
                    Math.pow(grass.position.z - playerZ, 2)
                );
                
                if (grassPlayerDistance > 60) {
                    // Move grass closer to player
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * 40 + 10;
                    grass.position.x = playerX + Math.cos(angle) * distance;
                    grass.position.z = playerZ + Math.sin(angle) * distance;
                    grass.userData.originalPosition.copy(grass.position);
                }
            });
            
            // Selective bloom rendering
            scene.traverse(darkenNonBloom); // Darken non-blooming objects
            bloomComposer.render(); // Render bloom effect
            
            scene.traverse(restoreMaterial); // Restore original materials
            composer.render(); // Render final scene with bloom merged
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Update composers
            bloomComposer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            
            // Update bloom pass
            bloomPass.setSize(window.innerWidth, window.innerHeight);
            
            // Update FXAA
            antialiasPass.material.uniforms['resolution'].value.x = 1 / window.innerWidth;
            antialiasPass.material.uniforms['resolution'].value.y = 1 / window.innerHeight;
        });

        animate();
    </script>
</body>
</html>